---
import type { Technology } from '../types/technology';
import HeaderInfo from './util/HeaderInfo.astro';

/**
 * Componente de galer√≠a de tecnolog√≠as con efecto de constelaci√≥n.
 * Las tecnolog√≠as se muestran como nodos interconectados con l√≠neas animadas.
 */

interface Props {
  technologies: Technology[];
}

const { technologies = [] } = Astro.props;

// Separar tecnolog√≠as por nivel de dominio
const masteredTechs = technologies.filter(tech => tech.proficiency >= 80);
const knownTechs = technologies.filter(tech => tech.proficiency < 80);
---

<article id="technologies">
  <HeaderInfo 
    title="Tecnolog√≠as" 
    subtitle="Mi Stack Tecnol√≥gico" 
  />
  
  <section class="pt-5!">
    <!-- Secci√≥n: Tecnolog√≠as Dominadas -->
    {masteredTechs.length > 0 && (
      <div class="reveal">
        <!-- T√≠tulo de la secci√≥n -->
        <div class="flex items-center justify-center gap-4">
          <div class="h-px w-16 bg-linear-to-r from-transparent to-aurora-cyan"></div>
          <div class="flex items-center gap-3 px-6! py-3! glass-effect rounded-full">
            <span class="text-2xl">‚ö°</span>
            <span class="text-lg font-bold text-winter-light">Dominadas</span>
            <span class="text-xs text-aurora-cyan font-semibold px-3! py-1! bg-aurora-cyan/20 rounded-full">
              80%+
            </span>
          </div>
          <div class="h-px w-16 bg-linear-to-l from-transparent to-aurora-cyan"></div>
        </div>

        <!-- Canvas para l√≠neas de conexi√≥n -->
        <div class="relative">
          <canvas 
            id="mastered-canvas" 
            class="constellation-canvas"
            aria-hidden="true"
          ></canvas>
          
          <!-- Grid de tecnolog√≠as -->
          <div class="tech-grid" id="mastered-grid">
            {masteredTechs.map((tech, index) => (
              <div 
                class="tech-node group" 
                data-tech-id={`mastered-${index}`}
                data-proficiency={tech.proficiency}
                data-color="cyan"
              >
                <!-- C√≠rculo de progreso animado -->
                <div class="progress-ring">
                  <svg class="w-full h-full -rotate-90" viewBox="0 0 120 120">
                    <!-- C√≠rculo de fondo -->
                    <circle
                      cx="60"
                      cy="60"
                      r="54"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      class="text-aurora-cyan/20"
                    />
                    <!-- C√≠rculo de progreso -->
                    <circle
                      cx="60"
                      cy="60"
                      r="54"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="3"
                      class="text-aurora-cyan progress-circle"
                      stroke-dasharray={`${2 * Math.PI * 54}`}
                      stroke-dashoffset={`${2 * Math.PI * 54 * (1 - tech.proficiency / 100)}`}
                      stroke-linecap="round"
                    />
                  </svg>
                </div>

                <!-- Contenido del nodo -->
                <div class="node-content">
                  <div class="tech-icon-wrapper" style={`--tech-color: ${tech.color}`}>
                    <Fragment set:html={tech.icon} />
                  </div>
                  <span class="tech-name">{tech.name}</span>
                  
                  <!-- Badge de nivel -->
                  <div class="proficiency-badge proficiency-cyan">
                    {tech.proficiency}%
                  </div>

                  <!-- Pulso animado al hacer hover -->
                  <div class="pulse-ring pulse-cyan"></div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    )}

    <!-- Secci√≥n: Tecnolog√≠as en Desarrollo -->
    {knownTechs.length > 0 && (
      <div class="reveal">
        <!-- T√≠tulo de la secci√≥n -->
        <div class="flex items-center justify-center gap-4">
          <div class="h-px w-16 bg-linear-to-r from-transparent to-aurora-purple"></div>
          <div class="flex items-center gap-3 px-6! py-3! glass-effect rounded-full">
            <span class="text-2xl">üéØ</span>
            <span class="text-lg font-bold text-winter-light">En Desarrollo</span>
            <span class="text-xs text-aurora-purple font-semibold px-3! py-1! bg-aurora-purple/20 rounded-full">
              {"<80%"}
            </span>
          </div>
          <div class="h-px w-16 bg-linear-to-l from-transparent to-aurora-purple"></div>
        </div>

        <!-- Canvas para l√≠neas de conexi√≥n -->
        <div class="relative">
          <canvas 
            id="known-canvas" 
            class="constellation-canvas"
            aria-hidden="true"
          ></canvas>
          
          <!-- Grid de tecnolog√≠as -->
          <div class="tech-grid" id="known-grid">
            {knownTechs.map((tech, index) => (
              <div 
                class="tech-node group" 
                data-tech-id={`known-${index}`}
                data-proficiency={tech.proficiency}
                data-color="purple"
              >
                <!-- C√≠rculo de progreso animado -->
                <div class="progress-ring">
                  <svg class="w-full h-full -rotate-90" viewBox="0 0 120 120">
                    <!-- C√≠rculo de fondo -->
                    <circle
                      cx="60"
                      cy="60"
                      r="54"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      class="text-aurora-purple/20"
                    />
                    <!-- C√≠rculo de progreso -->
                    <circle
                      cx="60"
                      cy="60"
                      r="54"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="3"
                      class="text-aurora-purple progress-circle"
                      stroke-dasharray={`${2 * Math.PI * 54}`}
                      stroke-dashoffset={`${2 * Math.PI * 54 * (1 - tech.proficiency / 100)}`}
                      stroke-linecap="round"
                    />
                  </svg>
                </div>

                <!-- Contenido del nodo -->
                <div class="node-content">
                  <div class="tech-icon-wrapper" style={`--tech-color: ${tech.color}`}>
                    <Fragment set:html={tech.icon} />
                  </div>
                  <span class="tech-name">{tech.name}</span>
                  
                  <!-- Badge de nivel -->
                  <div class="proficiency-badge proficiency-purple">
                    {tech.proficiency}%
                  </div>

                  <!-- Pulso animado al hacer hover -->
                  <div class="pulse-ring pulse-purple"></div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    )}
  </section>
</article>

<script>
  /**
   * Sistema de conexiones entre nodos tipo constelaci√≥n
   */
  interface NodePosition {
    x: number;
    y: number;
    element: HTMLElement;
  }

  class ConstellationCanvas {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private nodes: NodePosition[] = [];
    private animationId: number | null = null;
    private color: string;

    constructor(canvasId: string, gridId: string, color: 'cyan' | 'purple') {
      this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      if (!this.canvas) return;

      this.ctx = this.canvas.getContext('2d')!;
      this.color = color === 'cyan' ? '79, 195, 247' : '179, 157, 219'; // RGB de aurora-cyan/purple
      
      this.init(gridId);
      this.setupEventListeners();
      this.animate();
    }

    /**
     * Inicializa el canvas y calcula posiciones de nodos
     */
    private init(gridId: string): void {
      this.resize();
      this.calculateNodePositions(gridId);
    }

    /**
     * Ajusta el tama√±o del canvas al contenedor
     */
    private resize(): void {
      const parent = this.canvas.parentElement!;
      this.canvas.width = parent.offsetWidth;
      this.canvas.height = parent.offsetHeight;
    }

    /**
     * Calcula las posiciones centrales de cada nodo
     */
    private calculateNodePositions(gridId: string): void {
      const grid = document.getElementById(gridId);
      if (!grid) return;

      const nodeElements = grid.querySelectorAll('.tech-node') as NodeListOf<HTMLElement>;
      const canvasRect = this.canvas.getBoundingClientRect();

      this.nodes = Array.from(nodeElements).map(element => {
        const rect = element.getBoundingClientRect();
        return {
          x: rect.left + rect.width / 2 - canvasRect.left,
          y: rect.top + rect.height / 2 - canvasRect.top,
          element
        };
      });
    }

    /**
     * Dibuja l√≠neas entre nodos cercanos
     */
    private drawConnections(): void {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Distancia m√°xima para conectar nodos (en p√≠xeles)
      const maxDistance = 250;

      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const nodeA = this.nodes[i];
          const nodeB = this.nodes[j];

          const distance = Math.sqrt(
            Math.pow(nodeB.x - nodeA.x, 2) + 
            Math.pow(nodeB.y - nodeA.y, 2)
          );

          // Solo conectar si est√°n lo suficientemente cerca
          if (distance < maxDistance) {
            const opacity = (1 - distance / maxDistance) * 0.3;
            
            // Aumentar opacidad si alg√∫n nodo est√° en hover
            const isHovered = nodeA.element.matches(':hover') || nodeB.element.matches(':hover');
            const finalOpacity = isHovered ? opacity * 3 : opacity;

            this.ctx.beginPath();
            this.ctx.moveTo(nodeA.x, nodeA.y);
            this.ctx.lineTo(nodeB.x, nodeB.y);
            this.ctx.strokeStyle = `rgba(${this.color}, ${finalOpacity})`;
            this.ctx.lineWidth = isHovered ? 2 : 1;
            this.ctx.stroke();
          }
        }
      }
    }

    /**
     * Loop de animaci√≥n
     */
    private animate(): void {
      this.drawConnections();
      this.animationId = requestAnimationFrame(() => this.animate());
    }

    /**
     * Configura listeners para eventos
     */
    private setupEventListeners(): void {
      // Recalcular en resize
      window.addEventListener('resize', () => {
        this.resize();
        this.calculateNodePositions(
          this.canvas.id.replace('-canvas', '-grid')
        );
      });

      // Recalcular al hacer scroll (por si el layout cambia)
      let scrollTimeout: number;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          this.calculateNodePositions(
            this.canvas.id.replace('-canvas', '-grid')
          );
        }, 100) as unknown as number;
      });
    }

    /**
     * Limpia la animaci√≥n
     */
    public destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  /**
   * Inicializaci√≥n de efectos de scroll reveal
   */
  function initScrollReveal(): void {
    const revealElements = document.querySelectorAll('.reveal');
    const revealObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('active');
          }
        });
      },
      { threshold: 0.1, rootMargin: '0px 0px -50px 0px' }
    );

    revealElements.forEach((el) => revealObserver.observe(el));
  }

  /**
   * Inicializaci√≥n al cargar el DOM
   */
  document.addEventListener('DOMContentLoaded', () => {
    // Iniciar canvases de constelaci√≥n
    new ConstellationCanvas('mastered-canvas', 'mastered-grid', 'cyan');
    new ConstellationCanvas('known-canvas', 'known-grid', 'purple');

    // Iniciar efectos de reveal
    initScrollReveal();
  });
</script>

<style>
  /* ========================================
     Grid de tecnolog√≠as
     ======================================== */
  .tech-grid {
    position: relative;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 2rem;
    padding: 2rem;
    z-index: 10;
  }

  /* ========================================
     Canvas de constelaci√≥n (fondo)
     ======================================== */
  .constellation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  /* ========================================
     Nodo de tecnolog√≠a
     ======================================== */

  .tech-node {
    position: relative;
    aspect-ratio: 1;
    min-height: 160px;
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .tech-node:hover .tech-icon-wrapper {
    transform: scale(1.15) translateY(-4px);
  }

  /* A√±adir brillo al SVG en hover */
  .tech-node:hover .tech-icon-wrapper :global(svg) {
    filter: brightness(1.2);
  }

  /* ========================================
     Anillo de progreso
     ======================================== */
  .progress-ring {
    position: absolute;
    inset: 0;
    opacity: 0.4;
    transition: opacity 0.3s ease;
  }

  .tech-node:hover .progress-ring {
    opacity: 1;
  }

  /* Animaci√≥n del c√≠rculo de progreso */
  .progress-circle {
    transition: stroke-dashoffset 1s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* ========================================
     Contenido del nodo
     ======================================== */
  .node-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    padding: 1.5rem;
    border-radius: 1.25rem;
    background: rgba(30, 58, 95, 0.5);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(100, 181, 246, 0.2);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
  }

  .tech-node:hover .node-content {
    background: rgba(30, 58, 95, 0.7);
    border-color: rgba(100, 181, 246, 0.5);
    box-shadow: 
      0 12px 24px rgba(100, 181, 246, 0.2),
      inset 0 0 20px rgba(100, 181, 246, 0.1);
  }

  /* Variante purple */
  .tech-node[data-color="purple"] .node-content {
    border-color: rgba(179, 157, 219, 0.2);
  }

  .tech-node[data-color="purple"]:hover .node-content {
    border-color: rgba(179, 157, 219, 0.5);
    box-shadow: 
      0 12px 24px rgba(179, 157, 219, 0.2),
      inset 0 0 20px rgba(179, 157, 219, 0.1);
  }

  /* ========================================
     Icono de tecnolog√≠a
     ======================================== */
     /* ========================================
   Icono de tecnolog√≠a
   ======================================== */
.tech-icon-wrapper {
  width: 4rem;
  height: 4rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

/* Fuerza el color del SVG usando la variable CSS */
.tech-icon-wrapper :global(svg) {
  width: 100%;
  height: 100%;
  object-fit: contain;
  transition: all 0.3s ease;
  fill: var(--tech-color);
  color: var(--tech-color);
}

/* Resetea cualquier path interno que pueda tener fill por defecto */
.tech-icon-wrapper :global(svg) :global(path) {
  fill: inherit;
  stroke: inherit;
}

.tech-node:hover .tech-icon-wrapper {
  transform: scale(1.15) translateY(-4px);
}

  /* ========================================
     Nombre de tecnolog√≠a
     ======================================== */
  .tech-name {
    font-size: 0.9rem;
    font-weight: 700;
    text-align: center;
    color: var(--color-winter-light);
    line-height: 1.2;
    transition: color 0.3s ease;
  }

  .tech-node:hover .tech-name {
    color: var(--color-winter-snow);
  }

  /* ========================================
     Badge de proficiency
     ======================================== */
  .proficiency-badge {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    padding: 0.25rem 0.625rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 700;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  .proficiency-cyan {
    background: rgba(79, 195, 247, 0.9);
    color: var(--color-winter-dark);
    box-shadow: 0 0 10px rgba(79, 195, 247, 0.4);
  }

  .proficiency-purple {
    background: rgba(179, 157, 219, 0.9);
    color: var(--color-winter-dark);
    box-shadow: 0 0 10px rgba(179, 157, 219, 0.4);
  }

  .tech-node:hover .proficiency-badge {
    transform: scale(1.1);
  }

  /* ========================================
     Efecto de pulso al hover
     ======================================== */
  .pulse-ring {
    position: absolute;
    inset: -4px;
    border-radius: 1.25rem;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .pulse-cyan {
    box-shadow: 0 0 0 4px rgba(79, 195, 247, 0.3);
    animation: pulse-cyan 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .pulse-purple {
    box-shadow: 0 0 0 4px rgba(179, 157, 219, 0.3);
    animation: pulse-purple 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .tech-node:hover .pulse-ring {
    opacity: 1;
  }

  @keyframes pulse-cyan {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(79, 195, 247, 0.4);
    }
    50% {
      box-shadow: 0 0 0 12px rgba(79, 195, 247, 0);
    }
  }

  @keyframes pulse-purple {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(179, 157, 219, 0.4);
    }
    50% {
      box-shadow: 0 0 0 12px rgba(179, 157, 219, 0);
    }
  }

  /* ========================================
     Responsive
     ======================================== */
  @media (max-width: 768px) {
    .tech-grid {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1.5rem;
      padding: 1rem;
    }

    .tech-node {
      min-height: 140px;
    }

    .tech-name {
      font-size: 0.8rem;
    }

    .node-content {
      padding: 1rem;
    }

    .tech-icon-wrapper {
      width: 2.5rem;
      height: 2.5rem;
    }
  }

  @media (max-width: 480px) {
    .tech-grid {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .tech-node {
      min-height: 120px;
    }

    .tech-icon-wrapper {
      width: 2.5rem;
      height: 2.5rem;
    }
  }
</style>